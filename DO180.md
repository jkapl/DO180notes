# Overview of Container Technology
- Applications that rely on specific features or libraries in the OS (e.g. a particular version of a library like TLS 1.0) can break 
- container is a set of one or more processes that are isolated from the rest of the system. They also isolate the libraries and the runtime resources (such as CPU and storage) for an application to minimize the impact of any OS update to the host OS
    - When you build an application as a container image, which complies with the OCI standard, you can use any OCI-compliant container engine to execute the application.
    - Using containers, there is no longer a need to maintain separate production and development database servers. A single container image is used to create instances of the database service.\
    - many applications are not well suited for a containerized environment. For example, applications accessing low-level hardware information, such as memory, file systems, and devices may be unreliable due to container limitations.
- Kernel features that enable containers
    - Namespaces: resource isolation (processes, network iterfaces, mount points)
    - Control groups (cgroups): resource limits
    - Seccomp: limits how processes can use system calls
    - SELinux: Security Enhanced Linux, protects host from running processes and from each other
- Containers run an image: a file system bundle that contains dependencies required to execute a process
- Podman to manage containers
    - OCI Compliant and stores local images in local file-system so no need for daemon

## Podman
Useful commands:
- `podman search image-name`
- `podman run -d --name my-name actual-image-name echo "Hello!"`: -d detached mode, --name to give container custom name
- `podman inspect -l -f "{{.NetworkSettings.IPAddress}}"`: -l grabs latest used container, -f find
- `podman run -it image-name /bin/bash`: -it enable console interactivity
-  `podman run -e GREET=Hello -e NAME=RedHat rhel7"7/5 printenv GREET NAME`: -e set environment variables at container startup
**NOTE** Running a command after the container image name overrides the default entry point command. So with httpd for instance, the httpd service would not start if a command is passed in. Or with mysql, if a command is passed in, the mysql server will not start.
- Use -l flag to run a command in the last used container:
`sudo podman exec my-httpd-container cat /etc/hostname`
`sudo podman exec -l cat /etc/hostname`
- `podman inspect` to list metadata. Use Go template formatting to search with -f flag
`sudo podman inspect -f '{{ .NetworkSettings.IPAddress }}' my-httpd-container`
- `stop`, `kill`, `kill -s SIGKILL`
Stop then delete

### Persistent storage
Containers share read only image layers. Each container has access to its own read/write ephemeral layer. Podman can mount host directories inside a running container to provide persistent storage.
1. Create a director with owner and gropu root
`sudo mkdir /var/dbfiles/`
2. Give write permissions to the user id (UID) associated with the container. This UID may vary. In this example, it is 27
`sudo chown -R 27:27 /var/dbfiles`
3. Add the container_file_t SELinux context to the directory. This is necessary in RHEL for security.
`sudo semanage fcontext -a -t container_file_t '/var/dbfiles(/.*)?'`
4. Apply the SELinux container policy
`sudo restorecon -Rv /var/dbfiles `
Verify with
`ls -dZ /var/dbfiles`

To run the container with the file mount, use the `-v` flag.
`sudo podman run -v /var/dbfiles:/var/lib/mysql rhmap47/mysql`
This overlays the contents of /var/dbfiles onto the container directory /var/lib/mysql

### Networking
Podman attaches each container to a virtual bridge and assigns each container a private IP address
Config file is /etc/cni/net.d/87-podman-bridge.conflist
Traffic can flow to container with port forwarding rules. The following forwards traffic sent to port 8080 on the host to port 80 inside the container:
`sudo podman run -d --name apache1 -p 8080:80 rhscl/httpd-24-rhel7:2.4`

### Image Registries
Podman searches registries listed in this file: /etc/containers/registries.conf
`[registries.search]`
`registries = ["registry.access.redhat.com", "quay.io"]`

Save an image to a special .tar file using `podman save -o FILE_NAME IMAGE_NAME`: -o flag directs output to file instead of standard out. Tar file contains image metadata and original image layers. Load with `podman load -i FILE_NAME`
Delete images: `podman rmi`: -a flag for all, --force to remove all even if container is running
`podman commit [options] container-name [repository/image_name:tag]`: Create a new container image based on running container
`podman diff container-name`: show which files were changed, created or deleted. Does not include mounted files.
`podman inspect -f "{{range .Mounts}}{{println .Destination}}{{end}}" CONTAINER_NAME/ID`: list all mounted files and directories in running container
`podman tag image-name registry/name:tag`: tag an image